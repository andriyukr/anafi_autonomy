#!/usr/bin/env python3

import rospy
import csv
import cv2
import math
import os
import queue
import shlex
import subprocess
import tempfile
import threading
import traceback
import time
import logging
import roslib
import sys
import yaml
import olympe
import anafi_autonomy

from std_msgs.msg import UInt8, UInt16, UInt32, Int8, Float32, String, Header, Time, Empty, Bool
from geometry_msgs.msg import PoseStamped, PointStamped, QuaternionStamped, TwistStamped, Vector3Stamped, Quaternion, Twist, Vector3
from nav_msgs.msg import Odometry
from sensor_msgs.msg import Image, CameraInfo
from std_srvs.srv import Empty as EmptyServise
from tf.transformations import euler_from_quaternion
from cv_bridge import CvBridge, CvBridgeError

from olympe.messages.drone_manager import connection_state
from olympe.messages.ardrone3.Piloting import TakeOff, Landing, Emergency, PCMD
from olympe.messages.ardrone3.PilotingState import FlyingStateChanged, PositionChanged, SpeedChanged, AttitudeChanged, AltitudeChanged, GpsLocationChanged
from olympe.messages.ardrone3.PilotingSettings import MaxTilt, MaxDistance, MaxAltitude, NoFlyOverMaxDistance, BankedTurn
from olympe.messages.ardrone3.PilotingSettingsState import MaxTiltChanged, MaxDistanceChanged, MaxAltitudeChanged, NoFlyOverMaxDistanceChanged, BankedTurnChanged
from olympe.messages.ardrone3.SpeedSettings import MaxVerticalSpeed, MaxRotationSpeed, MaxPitchRollRotationSpeed
from olympe.messages.ardrone3.SpeedSettingsState import MaxVerticalSpeedChanged, MaxRotationSpeedChanged, MaxPitchRollRotationSpeedChanged
from olympe.messages.ardrone3.GPSSettingsState import GPSFixStateChanged
from olympe.messages.ardrone3.GPSState import NumberOfSatelliteChanged
from olympe.messages.rth import return_to_home, abort, set_ending_behavior, set_ending_hovering_altitude, set_min_altitude
from olympe.messages.skyctrl.CoPiloting import setPilotingSource
from olympe.messages.skyctrl.CoPilotingState import pilotingSource
from olympe.messages.skyctrl.Common import AllStates
from olympe.messages.skyctrl.CommonState import AllStatesChanged
from olympe.messages import gimbal, camera, mapper, leds
from olympe.enums.camera import availability

from dynamic_reconfigure.server import Server
from anafi_autonomy.cfg import setAnafiConfig
from anafi_autonomy.msg import PilotingCommand, MoveByCommand, MoveToCommand, CameraCommand, GimbalCommand, SkyControllerCommand
from anafi_autonomy.srv import TakePhoto

olympe.log.update_config({"loggers": {"olympe": {"level": "ERROR"}}})

DRONE_IP = "192.168.42.1"
SKYCTRL_IP = "192.168.53.1"

class Anafi(threading.Thread):
	def __init__(self):					
		self.pub_image = rospy.Publisher("/anafi/image", Image, queue_size=1)
		self.pub_camera_info = rospy.Publisher("/anafi/camera_info", CameraInfo, queue_size=1)
		self.pub_time = rospy.Publisher("/anafi/time", Time, queue_size=1)
		self.pub_attitude = rospy.Publisher("/anafi/attitude", QuaternionStamped, queue_size=1)
		self.pub_location = rospy.Publisher("/anafi/location", PointStamped, queue_size=1)
		self.pub_height = rospy.Publisher("/anafi/height", Float32, queue_size=1)
		self.pub_speed = rospy.Publisher("/anafi/speed", Vector3Stamped, queue_size=1)
		self.pub_air_speed = rospy.Publisher("/anafi/air_speed", Float32, queue_size=1)
		self.pub_link_goodput = rospy.Publisher("/anafi/link_goodput", UInt16, queue_size=1)
		self.pub_link_quality = rospy.Publisher("/anafi/link_quality", UInt8, queue_size=1)
		self.pub_wifi_rssi = rospy.Publisher("/anafi/wifi_rssi", Int8, queue_size=1)
		self.pub_battery = rospy.Publisher("/anafi/battery", UInt8, queue_size=1)
		self.pub_state = rospy.Publisher("/anafi/state", String, queue_size=1)
		self.pub_mode = rospy.Publisher("/anafi/mode", String, queue_size=1)
		self.pub_pose = rospy.Publisher("/anafi/pose", PoseStamped, queue_size=1)
		self.pub_odometry = rospy.Publisher("/anafi/odometry", Odometry, queue_size=1)
		self.pub_rpy = rospy.Publisher("/anafi/rpy", Vector3Stamped, queue_size=1)
		self.pub_gimbal_relative = rospy.Publisher("/anafi/gimbal/relative", Vector3Stamped, queue_size=1)
		self.pub_gimbal_absolute = rospy.Publisher("/anafi/gimbal/absolute", Vector3Stamped, queue_size=1)
		self.pub_zoom = rospy.Publisher("/anafi/zoom", Float32, queue_size=1)
		self.pub_skycontroller = rospy.Publisher("/skycontroller/command", SkyControllerCommand, queue_size=1)

		rospy.Subscriber("/anafi/takeoff", Empty, self.takeoff_callback)
		rospy.Subscriber("/anafi/land", Empty, self.land_callback)
		rospy.Subscriber("/anafi/emergency", Empty, self.emergency_callback)
		rospy.Subscriber("/anafi/rth", Empty, self.rth_callback)
		rospy.Subscriber("/anafi/offboard", Bool, self.offboard_callback)
		rospy.Subscriber("/anafi/cmd_rpyt", PilotingCommand, self.rpyt_callback)
		rospy.Subscriber("/anafi/cmd_moveto", MoveToCommand, self.moveTo_callback)
		rospy.Subscriber("/anafi/cmd_moveby", MoveByCommand, self.moveBy_callback)
		rospy.Subscriber("/anafi/cmd_camera", CameraCommand, self.camera_callback)
		rospy.Subscriber("/anafi/cmd_gimbal", GimbalCommand, self.gimbal_callback)
		
		rospy.Service('take_photo', TakePhoto, self.take_photo)
		rospy.Service('start_recording', EmptyServise, self.start_recording)
		rospy.Service('stop_recording', EmptyServise, self.stop_recording)
		rospy.Service('reset_zoom', EmptyServise, self.reset_zoom)
		rospy.Service('reset_gimbal', EmptyServise, self.reset_gimbal)
		
		# Connect to the SkyController	
		if rospy.get_param("/skycontroller"):
			rospy.loginfo("Connecting through SkyController");
			self.drone = olympe.Drone(SKYCTRL_IP)
		# Connect to the Anafi
		else:
			rospy.loginfo("Connecting directly to Anafi");
			self.drone = olympe.Drone(DRONE_IP)
		self.skyctrl = self.drone
		
		# Create listener for RC events
		self.event_listener = anafi_autonomy.EventListener(self)
		
		rospy.on_shutdown(self.stop)
			
		self.connect()
		
		self.srv = Server(setAnafiConfig, self.reconfigure_callback)	
		rospy.loginfo("HDR: " + str(self.drone.get_state(olympe.messages.camera.hdr_setting)[0]["value"]))
		
		# To convert OpenCV images to ROS images
		self.bridge = CvBridge()
			
		# Load data from file
		with open(os.path.abspath(os.path.dirname(__file__) + "/../../param/camera.yaml"), "r") as file_handle:
			camera_info = yaml.load(file_handle, Loader=yaml.FullLoader)
		rospy.loginfo("Camera info loaded from " + os.path.abspath(os.path.dirname(__file__) + "/../../param/camera.yaml"))
		# Parse camera info
		self.msg_camera_info = CameraInfo()
		self.msg_camera_info.width = camera_info["image_width"]
		self.msg_camera_info.height = camera_info["image_height"]
		self.msg_camera_info.K = camera_info["camera_matrix"]["data"]
		self.msg_camera_info.D = camera_info["distortion_coefficients"]["data"]
		self.msg_camera_info.R = camera_info["rectification_matrix"]["data"]
		self.msg_camera_info.P = camera_info["projection_matrix"]["data"]
		self.msg_camera_info.distortion_model = camera_info["distortion_model"]
		
		self.drone(camera.set_zoom_velocity_quality_degradation(cam_id=0, allow=0)) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_zoom_velocity_quality_degradation
		
		#print("animation.availability: " + str(self.drone.get_state(olympe.messages.animation.availability)))
		#print("leds.capabilities: " + str(self.drone.get_state(olympe.messages.leds.capabilities)))
		#print("camera.camera_capabilities: " + str(self.drone.get_state(olympe.messages.camera.camera_capabilities)))
			
	def connect(self):
		self.event_listener.subscribe()
		self.msg_skycontroller = SkyControllerCommand()
		self.msg_skycontroller.header.frame_id = '/body'
		
		rate = rospy.Rate(1) # 1hz
		while True:
			self.pub_state.publish("CONNECTING")
			connection = self.drone.connect()
			if getattr(connection, 'OK') == True:
				break
			if rospy.is_shutdown():
				exit()
			rate.sleep()
		
		# Connect to the SkyController	
		if rospy.get_param("/skycontroller"):
			self.pub_state.publish("CONNECTED_SKYCONTROLLER")
			rospy.loginfo("Connection to SkyController: " + getattr(connection, 'message'))
			self.switch_manual()
					
			# Connect to the drone
			while True:
				if self.drone(connection_state(state="connected", _policy="check")):
					break				
				if rospy.is_shutdown():
					exit()
				else:
					self.pub_state.publish("SERCHING_DRONE")
					rospy.loginfo_once("Connection to Anafi: " + str(self.drone.get_state(connection_state)["state"]))
				rate.sleep()
			self.pub_state.publish("CONNECTED_DRONE")			
			rospy.loginfo("Connection to Anafi: " + str(self.drone.get_state(connection_state)["state"]))
		# Connect to the Anafi
		else:
			self.pub_state.publish("CONNECTED_DRONE")
			rospy.loginfo("Connection to Anafi: " + getattr(connection, 'message'))
			self.switch_offboard()
			
		self.frame_queue = queue.Queue()
		self.flush_queue_lock = threading.Lock()

		# Setup the callback functions to do some live video processing
		self.drone.set_streaming_callbacks(
			raw_cb=self.yuv_frame_cb,
			flush_raw_cb=self.flush_cb
		)
		self.drone.start_video_streaming()		
		
	def disconnect(self):
		self.pub_state.publish("DISCONNECTING")
		self.msg_skycontroller = SkyControllerCommand()
		self.msg_skycontroller.header.stamp = rospy.Time.now()
		self.pub_skycontroller.publish(self.msg_skycontroller)
		
		self.event_listener.unsubscribe()
		#self.drone.stop_video_streaming()
		self.drone.disconnect()
		self.pub_state.publish("DISCONNECTED")
		
	def stop(self):
		rospy.loginfo("AnafiBridge is stopping...")
		self.disconnect()
						
	def reconfigure_callback(self, config, level):
		if level == -1 or level == 1: # piloting related
			self.drone(MaxTilt(config['max_tilt'])) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html?#olympe.messages.ardrone3.PilotingSettings.MaxTilt
			self.drone(MaxVerticalSpeed(config['max_vertical_speed'])) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.SpeedSettings.MaxVerticalSpeed
			self.drone(MaxRotationSpeed(config['max_yaw_rotation_speed'])) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.SpeedSettings.MaxRotationSpeed
			self.drone(MaxPitchRollRotationSpeed(config['max_pitch_roll_rotation_speed'])) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.SpeedSettings.MaxPitchRollRotationSpeed
			self.drone(MaxDistance(config['max_distance'])) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettings.MaxDistance
			self.drone(MaxAltitude(config['max_altitude'])) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettings.MaxAltitude
			self.drone(NoFlyOverMaxDistance(1)) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettings.NoFlyOverMaxDistance
			self.drone(BankedTurn(int(config['banked_turn']))) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettings.BankedTurn
			self.max_tilt = config['max_tilt']
			self.max_horizontal_speed = config['max_horizontal_speed']
			self.max_vertical_speed = config['max_vertical_speed']
			self.max_rotation_speed = config['max_yaw_rotation_speed']
		if level == -1 or level == 2: # RTH related
			self.drone(set_ending_behavior( # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.set_ending_behavior
				ending_behavior='landing' if config['ending_behavior'] == 0 else 'hovering' # {'landing', 'hovering'}
				))
			self.drone(set_ending_hovering_altitude( # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.set_ending_hovering_altitude
				altitude=config['hovering_altitude'] # AGL altitude (m)
				))
			self.drone(set_min_altitude( # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.set_min_altitude
				altitude=config['min_altitude'] # ATO altitude (m)
				))
		if level == -1 or level == 3: # camera related
			self.gimbal_frame = 'absolute' if config['gimbal_absolute'] else 'relative'
			self.drone(gimbal.set_max_speed(
				gimbal_id=0,
				yaw=0, 
				pitch=config['max_gimbal_speed'], # [1, 180] (deg/s)
				roll=config['max_gimbal_speed'] # [1, 180] (deg/s)
				))
			self.max_gimbal_speed = config['max_gimbal_speed']
			self.drone(camera.set_max_zoom_speed(
				cam_id=0,
				max=config['max_zoom_speed'] # [0.01, 10] (tan(deg)/sec)
				))
			self.drone(camera.set_hdr_setting(
				cam_id=0,
				value=availability.available if config['hdr'] else availability.not_available
				))
		return config
		
	# This function will be called by Olympe for each decoded YUV frame.
	def yuv_frame_cb(self, yuv_frame):      
		yuv_frame.ref()
		self.frame_queue.put_nowait(yuv_frame)

	def flush_cb(self):
		with self.flush_queue_lock:
			while not self.frame_queue.empty():
				self.frame_queue.get_nowait().unref()
		return True

	def yuv_callback(self, yuv_frame):
		# Use OpenCV to convert the yuv frame to RGB
		info = yuv_frame.info() # the VideoFrame.info() dictionary contains some useful information such as the video resolution
		rospy.logdebug_throttle(10, "yuv_frame.info = " + str(info))
		cv2_cvt_color_flag = {
			olympe.PDRAW_YUV_FORMAT_I420: cv2.COLOR_YUV2BGR_I420,
			olympe.PDRAW_YUV_FORMAT_NV12: cv2.COLOR_YUV2BGR_NV12,
		}[info["yuv"]["format"]] # convert pdraw YUV flag to OpenCV YUV flag
		cv2frame = cv2.cvtColor(yuv_frame.as_ndarray(), cv2_cvt_color_flag)
		
		# Publish image
		msg_image = self.bridge.cv2_to_imgmsg(cv2frame, "bgr8")
		self.pub_image.publish(msg_image)
		
		# Publish camera info
		self.pub_camera_info.publish(self.msg_camera_info)

		# yuv_frame.vmeta() returns a dictionary that contains additional metadata from the drone (GPS coordinates, battery percentage, ...)
		metadata = yuv_frame.vmeta()
		rospy.logdebug_throttle(10, "yuv_frame.vmeta = " + str(metadata))
				
		if metadata[1] != None:
			header = Header()
			header.stamp = rospy.Time.now()
			header.frame_id = '/body'
		
			frame_timestamp = metadata[1]['frame_timestamp'] # timestamp [millisec]
			msg_time = Time()
			msg_time.data = frame_timestamp # secs = int(frame_timestamp//1e6), nsecs = int(frame_timestamp%1e6*1e3)
			self.pub_time.publish(msg_time)

			drone_quat = metadata[1]['drone_quat'] # attitude
			msg_attitude = QuaternionStamped()
			msg_attitude.header = header
			msg_attitude.quaternion = Quaternion(drone_quat['x'], -drone_quat['y'], -drone_quat['z'], drone_quat['w'])
			self.pub_attitude.publish(msg_attitude)
					
			location = metadata[1]['location'] # GPS location [500.0=not available] (decimal deg)
			msg_location = PointStamped()
			if location != {}:			
				msg_location.header = header
				msg_location.header.frame_id = '/world'
				msg_location.point.x = location['latitude']
				msg_location.point.y = location['longitude']
				msg_location.point.z = location['altitude']
				self.pub_location.publish(msg_location)
				
			ground_distance = metadata[1]['ground_distance'] # barometer (m)
			self.pub_height.publish(ground_distance)

			speed = metadata[1]['speed'] # opticalflow speed (m/s)
			msg_speed = Vector3Stamped()
			msg_speed.header = header
			msg_speed.header.frame_id = '/world'
			msg_speed.vector.x = speed['north']
			msg_speed.vector.y = -speed['east']
			msg_speed.vector.z = -speed['down']
			self.pub_speed.publish(msg_speed)

			air_speed = metadata[1]['air_speed'] # air speed [-1=no data, > 0] (m/s)
			self.pub_air_speed.publish(air_speed)

			link_goodput = metadata[1]['link_goodput'] # throughput of the connection (b/s)
			self.pub_link_goodput.publish(link_goodput)

			link_quality = metadata[1]['link_quality'] # [0=bad, 5=good]
			self.pub_link_quality.publish(link_quality)

			wifi_rssi = metadata[1]['wifi_rssi'] # signal strength [-100=bad, 0=good] (dBm)
			self.pub_wifi_rssi.publish(wifi_rssi)

			battery_percentage = metadata[1]['battery_percentage'] # [0=empty, 100=full]
			self.pub_battery.publish(battery_percentage)

			state = metadata[1]['state'] # ['LANDED', 'MOTOR_RAMPING', 'TAKINGOFF', 'HOWERING', 'FLYING', 'LANDING', 'EMERGENCY']
			self.pub_state.publish(state)

			mode = metadata[1]['mode'] # ['MANUAL', 'RETURN_HOME', 'FLIGHT_PLAN', 'TRACKING', 'FOLLOW_ME', 'MOVE_TO']
			self.pub_mode.publish(mode)
			
			msg_pose = PoseStamped()
			msg_pose.header = header
			msg_pose.pose.position = msg_location.point
			msg_pose.pose.position.z = ground_distance
			msg_pose.pose.orientation = msg_attitude.quaternion
			self.pub_pose.publish(msg_pose)
			
			quaternion = [drone_quat['x'], -drone_quat['y'], -drone_quat['z'], drone_quat['w']]
			(roll, pitch, yaw) = euler_from_quaternion(quaternion)
			msg_rpy = Vector3Stamped()
			msg_rpy.header = header
			msg_rpy.header.frame_id = '/world'
			msg_rpy.vector.x = roll*180/math.pi
			msg_rpy.vector.y = pitch*180/math.pi
			msg_rpy.vector.z = yaw*180/math.pi
			self.pub_rpy.publish(msg_rpy)
			
			msg_odometry = Odometry()
			msg_odometry.header = header
			msg_odometry.child_frame_id = '/body'
			msg_odometry.pose.pose = msg_pose.pose
			msg_odometry.twist.twist.linear.x =  math.cos(yaw)*msg_speed.vector.x + math.sin(yaw)*msg_speed.vector.y
			msg_odometry.twist.twist.linear.y = -math.sin(yaw)*msg_speed.vector.x + math.cos(yaw)*msg_speed.vector.y
			msg_odometry.twist.twist.linear.z = msg_speed.vector.z
			self.pub_odometry.publish(msg_odometry)
			
			# log battery percentage
			if battery_percentage >= 30:
				if battery_percentage%10 == 0:
					rospy.loginfo_throttle(100, "Battery level: " + str(battery_percentage) + "%")
			else:
				if battery_percentage >= 20:
					rospy.logwarn_throttle(10, "Low battery: " + str(battery_percentage) + "%")
				else:
					if battery_percentage >= 10:
						rospy.logerr_throttle(1, "Critical battery: " + str(battery_percentage) + "%")
					else:
						rospy.logfatal_throttle(0.1, "Empty battery: " + str(battery_percentage) + "%")		
					
			# log signal strength
			if wifi_rssi <= -60:
				if wifi_rssi >= -70:
					rospy.loginfo_throttle(100, "Signal strength: " + str(wifi_rssi) + "dBm")
				else:
					if wifi_rssi >= -80:
						rospy.logwarn_throttle(10, "Weak signal: " + str(wifi_rssi) + "dBm")
					else:
						if wifi_rssi >= -90:
							rospy.logerr_throttle(1, "Unreliable signal:" + str(wifi_rssi) + "dBm")
						else:
							rospy.logfatal_throttle(0.1, "Unusable signal: " + str(wifi_rssi) + "dBm")
		else:
			rospy.logwarn("Packet lost!")
		
	def takeoff_callback(self, msg):
		rospy.logwarn("Takeoff")		
		assert self.drone(TakeOff() >> FlyingStateChanged(state="hovering", _timeout=10)).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.TakeOff

	def land_callback(self, msg):		
		rospy.loginfo("Land")
		assert self.drone(Landing()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.Landing
		
	def emergency_callback(self, msg):		
		rospy.logfatal("Emergency!!!")
		assert self.drone(Emergency()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.Emergency
		
	def rth_callback(self, msg):		
		rospy.loginfo("Return to Home")
		assert self.drone(PCMD(flag=1, roll=0, pitch=0, yaw=0, gaz=0, timestampAndSeqNum=0)).wait().success()
		self.drone(return_to_home()) # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.return_to_home
		
	def offboard_callback(self, msg):
		if msg.data == False:	
			self.switch_manual()
		else:
			self.switch_offboard()
						
	def rpyt_callback(self, msg):
		self.drone(PCMD( # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.PCMD
			flag=1,
			roll=int(self.bound_percentage(msg.roll/self.max_tilt*100)), # roll [-100, 100] (% of max tilt)
			pitch=int(self.bound_percentage(msg.pitch/self.max_tilt*100)), # pitch [-100, 100] (% of max tilt)
			yaw=int(self.bound_percentage(-msg.yaw/self.max_rotation_speed*100)), # yaw rate [-100, 100] (% of max yaw rate)
			gaz=int(self.bound_percentage(msg.gaz/self.max_vertical_speed*100)), # vertical speed [-100, 100] (% of max vertical speed)
			timestampAndSeqNum=0)) # for debug only

	# TODO: NOT USED YET	
	def moveBy_callback(self, msg):		
		assert self.drone(move.extended_move_by( # https://developer.parrot.com/docs/olympe/arsdkng_move.html?#olympe.messages.move.extended_move_by
			d_x=msg.dx, # displacement along the front axis (m)
			d_y=msg.dy, # displacement along the right axis (m)
			d_z=msg.dz, # displacement along the down axis (m)
			d_psi=msg.dyaw, # rotation of heading (rad)
			max_horizontal_speed=self.max_horizontal_speed,
			max_vertical_speed=self.max_vertical_speed,
			max_yaw_rotation_speed=self.max_rotation_speed
			) # >> FlyingStateChanged(state="hovering", _timeout=5)
			).wait().success()
	
	# TODO: NOT USED YET	
	def moveTo_callback(self, msg):		
		assert self.drone(move.extended_move_to( # https://developer.parrot.com/docs/olympe/arsdkng_move.html?#olympe.messages.move.extended_move_to
			latitude=msg.latitude, # latitude (degrees)
			longitude=msg.longitude, # longitude (degrees)
			altitude=msg.altitude, # altitude (m)
			orientation_mode='heading_start', # orientation mode {'to_target', 'heading_start', 'heading_during'}
			heading=msg.heading, # heading relative to the North (degrees)
			max_horizontal_speed=self.max_horizontal_speed,
			max_vertical_speed=self.max_vertical_speed,
			max_yaw_rotation_speed=self.max_rotation_speed
			) # >> FlyingStateChanged(state="hovering", _timeout=5)
			).wait().success()

	def camera_callback(self, msg):
		self.drone(camera.set_zoom_target( # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_zoom_target
			cam_id=0,
			control_mode='level' if msg.mode==0 else 'velocity', # {'level', 'velocity'}
			target=msg.zoom)) # (in level mode [1,3])
		
	def gimbal_callback(self, msg):
		self.drone(gimbal.set_target( # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.set_target
			gimbal_id=0,
			control_mode='position' if msg.mode==0 else 'velocity', # {'position', 'velocity'}
			yaw_frame_of_reference='none',
			yaw=0.0,
			pitch_frame_of_reference=self.gimbal_frame, # {'absolute', 'relative', 'none'}
			pitch=-msg.pitch, # (in position mode [-135,105])
			roll_frame_of_reference=self.gimbal_frame, # {'absolute', 'relative', 'none'}
			roll=msg.roll)) # (in position mode [-38,38])
				
	def take_photo(self, req):
		rospy.loginfo("Taking photo")
		self.drone(camera.set_camera_mode(cam_id=0, value="photo")).wait()
		self.drone(camera.take_photo(cam_id=0)) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.take_photo
		self.drone(camera.set_camera_mode(cam_id=0, value="recording")).wait()
		return []
		
	def start_recording(self, req):
		rospy.loginfo("Starting recording")
		self.drone(camera.set_camera_mode(cam_id=0, value="recording")).wait() # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_camera_mode
		self.drone(camera.start_recording(cam_id=0)) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.start_recording
		return []
		
	def stop_recording(self, req):
		rospy.loginfo("Stoping recording")
		self.drone(camera.stop_recording(cam_id=0)).wait() # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.stop_recording
		return []
		
	def reset_zoom(self, req):
		rospy.loginfo("Reseting zoom")
		self.drone(camera.set_zoom_target(cam_id=0, control_mode='level', target=1)).wait()
		return []
		
	def reset_gimbal(self, req):
		rospy.loginfo("Reseting gimbal")
		self.drone(gimbal.set_max_speed(gimbal_id=0, yaw=0, pitch=180, roll=180))
		self.drone(gimbal.set_target(gimbal_id=0, control_mode='position', yaw_frame_of_reference='none', yaw=0.0, pitch_frame_of_reference=self.gimbal_frame, pitch=0.0, roll_frame_of_reference='relative', roll=0.0)).wait()
		self.drone(gimbal.set_max_speed(gimbal_id=0, yaw=0, pitch=self.max_gimbal_speed, roll=self.max_gimbal_speed))
		return []

	def switch_manual(self):
		self.drone(abort()) # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.abort
	
		self.msg_skycontroller = SkyControllerCommand()
		self.msg_skycontroller.header.stamp = rospy.Time.now()
		self.pub_skycontroller.publish(self.msg_skycontroller)
		
		# button: 	0 = RTH, 1 = takeoff/land, 2 = back left, 3 = back right
		self.drone(mapper.grab(buttons=(0<<0|0<<1|0<<2|1<<3), axes=0)).wait() # bitfields
		self.drone(setPilotingSource(source="SkyController")).wait()
		rospy.loginfo("Control: Manual")
			
	def switch_offboard(self):
		# button: 	0 = RTH, 1 = takeoff/land, 2 = back left, 3 = back right
		# axis: 	0 = yaw, 1 = trottle, 2 = roll, 3 = pithch, 4 = camera, 5 = zoom
		self.drone(mapper.grab(buttons=(1<<0|0<<1|1<<2|1<<3), axes=(1<<0|1<<1|1<<2|1<<3|1<<4|1<<5))) # bitfields
		self.drone(setPilotingSource(source="Controller")).wait()
		rospy.loginfo("Control: Offboard")
			
	def bound(self, value, value_min, value_max):
		return min(max(value, value_min), value_max)
		
	def bound_percentage(self, value):
		return self.bound(value, -100, 100)

	def run(self): 
		rate = rospy.Rate(100) # 100hz
		
		rospy.logdebug('MaxTilt = %f [%f, %f]', self.drone.get_state(MaxTiltChanged)["current"], self.drone.get_state(MaxTiltChanged)["min"], self.drone.get_state(MaxTiltChanged)["max"])
		rospy.logdebug('MaxVerticalSpeed = %f [%f, %f]', self.drone.get_state(MaxVerticalSpeedChanged)["current"], self.drone.get_state(MaxVerticalSpeedChanged)["min"], self.drone.get_state(MaxVerticalSpeedChanged)["max"])
		rospy.logdebug('MaxRotationSpeed = %f [%f, %f]', self.drone.get_state(MaxRotationSpeedChanged)["current"], self.drone.get_state(MaxRotationSpeedChanged)["min"], self.drone.get_state(MaxRotationSpeedChanged)["max"])
		rospy.logdebug('MaxPitchRollRotationSpeed = %f [%f, %f]', self.drone.get_state(MaxPitchRollRotationSpeedChanged)["current"], self.drone.get_state(MaxPitchRollRotationSpeedChanged)["min"], self.drone.get_state(MaxPitchRollRotationSpeedChanged)["max"])
		rospy.logdebug('MaxDistance = %f [%f, %f]', self.drone.get_state(MaxDistanceChanged)["current"], self.drone.get_state(MaxDistanceChanged)["min"], self.drone.get_state(MaxDistanceChanged)["max"])
		rospy.logdebug('MaxAltitude = %f [%f, %f]', self.drone.get_state(MaxAltitudeChanged)["current"], self.drone.get_state(MaxAltitudeChanged)["min"], self.drone.get_state(MaxAltitudeChanged)["max"])
		rospy.logdebug('NoFlyOverMaxDistance = %i', self.drone.get_state(NoFlyOverMaxDistanceChanged)["shouldNotFlyOver"])
		rospy.logdebug('BankedTurn = %i', self.drone.get_state(BankedTurnChanged)["state"])
		
		while not rospy.is_shutdown():
			connection = self.drone.connection_state()
			if getattr(connection, 'OK') == False:
				rospy.logfatal(getattr(connection, 'message'))
				self.disconnect()
				self.connect()
					
			self.gimbal = self.drone.get_state(gimbal.attitude)[0]
			msg_gimbal = Vector3Stamped()
			msg_gimbal.header.stamp = rospy.Time.now()
			msg_gimbal.header.frame_id = '/world'
			msg_gimbal.vector.x = self.gimbal['roll_absolute']
			msg_gimbal.vector.y = -self.gimbal['pitch_absolute']
			msg_gimbal.vector.z = -self.gimbal['yaw_absolute']
			self.pub_gimbal_absolute.publish(msg_gimbal)
			msg_gimbal.header.frame_id = '/body'
			msg_gimbal.vector.x = self.gimbal['roll_relative']
			msg_gimbal.vector.y = -self.gimbal['pitch_relative']
			msg_gimbal.vector.z = -self.gimbal['yaw_relative']
			self.pub_gimbal_relative.publish(msg_gimbal)
			
			self.zoom = self.drone.get_state(camera.zoom_level)[0]['level']
			self.pub_zoom.publish(self.zoom)
			
			with self.flush_queue_lock:
				try:					
					yuv_frame = self.frame_queue.get(timeout=0.01)
				except queue.Empty:
					continue
				
				try:
					self.yuv_callback(yuv_frame)
				except Exception:
					# Continue popping frame from the queue even if it fails to show one frame
					traceback.print_exc()
					continue
				finally:
					# Unref the yuv frame to avoid starving the video buffer pool
					yuv_frame.unref()
					
			self.msg_skycontroller.header.stamp = rospy.Time.now()
			self.pub_skycontroller.publish(self.msg_skycontroller)
			
			# Publish button pressing event only once
			self.msg_skycontroller.RTL = False
			self.msg_skycontroller.takeoff_land = False
			self.msg_skycontroller.reset_camera = False
			self.msg_skycontroller.reset_zoom = False
								
			rate.sleep()

if __name__ == '__main__':
	rospy.init_node('anafi', anonymous = False)
	rospy.loginfo("Anafi is running...")
	anafi = Anafi()	
	try:
		anafi.run()
	except rospy.ROSInterruptException:
		#traceback.print_exc()
		pass
